package com.example.marksmanagement.service;

import com.example.marksmanagement.model.ExamType;
import com.example.marksmanagement.model.Marks;
import com.example.marksmanagement.model.Student;
import com.example.marksmanagement.model.Subject;
import com.example.marksmanagement.repository.MarksRepository;
import com.example.marksmanagement.repository.StudentRepository;
import com.example.marksmanagement.repository.SubjectRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.Comparator;

@Service
public class MarksServiceImpl implements MarksService {

    private MarksRepository marksRepository;
    private StudentRepository studentRepository;
    private SubjectRepository subjectRepository;

    @Autowired
    public void setMarksRepository(MarksRepository marksRepository) {
        this.marksRepository = marksRepository;
    }

    @Autowired
    public void setStudentRepository(StudentRepository studentRepository) {
        this.studentRepository = studentRepository;
    }

    @Autowired
    public void setSubjectRepository(SubjectRepository subjectRepository) {
        this.subjectRepository = subjectRepository;
    }

    @Override
    public List<Marks> getAllMarks() {
        return marksRepository.findAll();
    }

    @Override
    public List<Marks> getMarksByStudentRollNumber(String rollNumber) {
        Optional<Student> student = studentRepository.findById(rollNumber);
        return student.map(marksRepository::findByStudent).orElse(Collections.emptyList());
    }

    @Override
    public List<Marks> getMarksByStudentAndExamType(String rollNumber, ExamType examType) {
        try {
            System.out.println("Attempting direct query for student marks with rollNumber=" + rollNumber + ", examType=" + examType);
            // First try direct query with rollNumber if repository supports it
            List<Marks> marks = marksRepository.findByStudent_RollNumberAndExamType(rollNumber, examType);
            System.out.println("Found " + marks.size() + " marks directly using rollNumber query");
            return marks;
        } catch (Exception e) {
            // Fallback to the original implementation if direct query fails
            System.out.println("Direct query failed, falling back to student object query: " + e.getMessage());
            try {
                Optional<Student> student = studentRepository.findById(rollNumber);
                if (!student.isPresent()) {
                    System.out.println("Student not found with rollNumber: " + rollNumber);
                    return Collections.emptyList();
                }
                
                List<Marks> marks = marksRepository.findByStudentAndExamType(student.get(), examType);
                System.out.println("Found " + marks.size() + " marks using student object query");
                return marks;
            } catch (Exception ex) {
                System.err.println("Error in fallback query: " + ex.getMessage());
                ex.printStackTrace();
                return Collections.emptyList();
            }
        }
    }

    @Override
    public Optional<Marks> getMarksByStudentSubjectAndExamType(String rollNumber, Long subjectId, ExamType examType) {
        Optional<Student> student = studentRepository.findById(rollNumber);
        Optional<Subject> subject = subjectRepository.findById(subjectId);
        
        if (student.isPresent() && subject.isPresent()) {
            return marksRepository.findByStudentAndSubjectAndExamType(student.get(), subject.get(), examType);
        }
        return Optional.empty();
    }

    @Override
    public Marks saveMarks(Marks marks) {
        return marksRepository.save(marks);
    }

    @Override
    public Marks updateMarks(Marks marks) {
        return marksRepository.save(marks);
    }

    @Override
    public void deleteMarks(Long id) {
        marksRepository.deleteById(id);
    }

    @Override
    public List<TopRankerDTO> getTop3Rankers() {
        List<Marks> allMarks = marksRepository.findAll();
        
        // Group marks by student and calculate total
        Map<Student, Double> studentTotals = allMarks.stream()
            .collect(Collectors.groupingBy(
                Marks::getStudent,
                Collectors.summingDouble(Marks::getMarks)
            ));
        
        // Convert to DTOs and sort by total marks
        return studentTotals.entrySet().stream()
            .map(entry -> new TopRankerDTO(
                entry.getKey().getName(),
                entry.getKey().getRollNumber(),
                entry.getValue()
            ))
            .sorted(Comparator.comparing(TopRankerDTO::getTotalMarks).reversed())
            .limit(3)
            .collect(Collectors.toList());
    }
    
    @Override
    public List<TopRankerDTO> getTop3RankersByExamType(ExamType examType) {
        List<Marks> allMarks = marksRepository.findAll();
        
        // Filter by exam type and group marks by student and calculate total
        Map<Student, Double> studentTotals = allMarks.stream()
            .filter(mark -> mark.getExamType() == examType)
            .collect(Collectors.groupingBy(
                Marks::getStudent,
                Collectors.summingDouble(Marks::getMarks)
            ));
        
        // Convert to DTOs and sort by total marks
        return studentTotals.entrySet().stream()
            .map(entry -> new TopRankerDTO(
                entry.getKey().getName(),
                entry.getKey().getRollNumber(),
                entry.getValue()
            ))
            .sorted(Comparator.comparing(TopRankerDTO::getTotalMarks).reversed())
            .limit(3)
            .collect(Collectors.toList());
    }
} 